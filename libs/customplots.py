import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
from itertools import product
from libs.utils import round_sig_figs

def ts_with_hist(
        df: pd.DataFrame, 
        ylabel: str = None, 
        ylim: float = None, 
        title: str = '', 
        bin_width: float = 1.,
        color: str = 'black',
        lw: float = 0.3,
        alpha: float = 0.3, 
        **kwargs
        ):

    '''
    plots ensemble timeseries using summary csvs generated by Calculate_ensemble_SLC.py. 
    Includes a histogram of final values aligned with timeseries axis.

    inputs:
        - data: pandas dataframe with columns as run numbers and rows as years
        - ylab: label for timeseries y axis
        - **kwargs: key word arguments for timeseries axis
    '''

    fig, ax = plt.subplots(ncols=2, figsize=(8, 5), sharey=True, width_ratios=[3, 1], dpi=600)

    # plot timeseries
    ax[0].plot(
        df,
        color=color,
        alpha=alpha,
        lw=lw,
        **kwargs
        )
    
    # plot histogram
    slc = df.iloc[-1]
    ymin = np.floor(slc.min())
    ymax = np.ceil(slc.max())
    bins = np.arange(ymin, ymax+bin_width, bin_width)
    ax[1].hist(
        slc,
        bins = bins,
        orientation='horizontal',
        color='black',
    )

    # timeseries axis options
    xmax = round_sig_figs(slc.name)
    offset = xmax/50
    ax[0].set_xlim([-offset, xmax])
    ax[0].set_ylim(ylim)
    ax[0].set_xlabel('Time ($yrs$)')
    ax[0].set_ylabel(ylabel)
    ax[0].set_title(title)
    ax[0].tick_params(axis='both', direction='in')
    ax[0].hlines(0, 0, 10_000, lw=0.5, color='red') 

    # histogram axis options
    ax[1].tick_params(axis='y', color='none')
    ax[1].set_xticks([])

    fig.subplots_adjust(wspace=0.05)

def sensitivity(df, output, mask=None, relabel={}, colors=None, **kwargs):

    parameters = df.columns
    if colors:
        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=colors) 


    # account for weird indexing, ensures groupby works correctly
    N = len(output)
    df.index = range(N)
    output.index = range(N)

    fig, axes = plt.subplots(ncols=3, nrows=2, figsize=(10, 5), dpi=600)

    for param, ax in zip(parameters, axes.flatten()):

        if mask is None:
            ax.scatter(df[param], output, **kwargs)
        else:
            for (_, param_group), (_, output_group) in zip(df.groupby(mask), output.groupby(mask)):
                ax.scatter(param_group[param], output_group, **kwargs)

        ax.set_xlabel(relabel.get(param, param))
        formatter = mticker.ScalarFormatter(useMathText=True)
        ax.xaxis.set_major_formatter(formatter)
        ax.ticklabel_format(style='sci', scilimits=(-2, 2))

    for i, j in product(range(3), range(2)):
        if i == 0:
            axes[j][i].set_ylabel('sea level contribution ($m$)')
        else:
            axes[j][i].tick_params(axis='y', which='both', left=False, labelleft=False)

    axes[1][2].set_axis_off()
    fig.subplots_adjust(hspace=0.4, wspace=0.1)